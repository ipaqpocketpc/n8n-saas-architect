#!/usr/bin/env node
/**
 * Root Folder Cleanup Script
 * Auto-generated by cleanup-generator.js
 * Config: Generic Project
 *
 * Gebruik:
 *   node scripts/cleanup-root.js          # Check voor violations
 *   node scripts/cleanup-root.js --fix    # Auto-fix violations
 *   node scripts/cleanup-root.js --dry-run --fix  # Preview fixes
 */

const fs = require('fs');
const path = require('path');

const ROOT = path.resolve(__dirname, '..');
const args = process.argv.slice(2);
const FIX_MODE = args.includes('--fix');
const DRY_RUN = args.includes('--dry-run');

// Configuratie
const CONFIG = {
  "name": "Generic Project",
  "description": "Algemeen project zonder specifiek framework",
  "allowedInRoot": [
    "README.md",
    "CLAUDE.md",
    "LICENSE",
    "package.json",
    "package-lock.json",
    "tsconfig.json",
    ".env.example"
  ],
  "allowedFolders": [
    ".git",
    "node_modules",
    "src",
    "lib",
    "scripts",
    "docs",
    "tests",
    "dist",
    "build",
    "output"
  ],
  "allowedPatterns": [
    "^\\..*"
  ],
  "moveRules": {
    "*.md": "docs/",
    "*.html": "docs/",
    "*.xml": "docs/",
    "*.js": "scripts/",
    "*.ts": "scripts/",
    "*.xlsx": "data/",
    "*.csv": "data/",
    "*.json": "data/"
  },
  "deletePatterns": [
    "nul",
    "Thumbs.db",
    "Desktop.ini",
    ".DS_Store",
    "*.tmp",
    "*.temp",
    "*.bak",
    "*.swp",
    "UsersSSD*",
    "*AppData*",
    "*Temp*.json"
  ],
  "gitignoreTemplate": "generic"
};

// Kleuren
const c = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m'
};

function log(msg, color = 'reset') {
  console.log(`${c[color]}${msg}${c.reset}`);
}

// Check of bestand voldoet aan allowed patterns
function matchesPattern(filename, patterns) {
  return patterns.some(pattern => {
    if (pattern.startsWith('^') || pattern.endsWith('$')) {
      return new RegExp(pattern).test(filename);
    }
    // Glob-style matching
    const regexPattern = pattern
      .replace(/\./g, '\\.')
      .replace(/\*/g, '.*')
      .replace(/\?/g, '.');
    return new RegExp(`^${regexPattern}$`).test(filename);
  });
}

// Check of bestand moet worden verwijderd
function shouldDelete(filename) {
  return matchesPattern(filename, CONFIG.deletePatterns);
}

// Bepaal waar bestand naartoe moet
function getMoveDestination(filename) {
  for (const [pattern, dest] of Object.entries(CONFIG.moveRules)) {
    if (matchesPattern(filename, [pattern])) {
      return dest;
    }
  }
  return null;
}

// Scan root folder
function scanRoot() {
  const items = fs.readdirSync(ROOT);
  const violations = {
    delete: [],
    move: [],
    review: []
  };

  for (const item of items) {
    const itemPath = path.join(ROOT, item);
    const isDir = fs.statSync(itemPath).isDirectory();

    // Skip allowed folders
    if (isDir && CONFIG.allowedFolders.includes(item)) continue;

    // Skip allowed files
    if (!isDir && CONFIG.allowedInRoot.includes(item)) continue;

    // Skip files matching allowed patterns
    if (!isDir && matchesPattern(item, CONFIG.allowedPatterns || [])) continue;

    // Check delete patterns
    if (!isDir && shouldDelete(item)) {
      violations.delete.push({ name: item, path: itemPath });
      continue;
    }

    // Check move rules
    if (!isDir) {
      const dest = getMoveDestination(item);
      if (dest) {
        violations.move.push({ name: item, path: itemPath, dest });
        continue;
      }
    }

    // Onbekend - needs review
    violations.review.push({ name: item, path: itemPath, isDir });
  }

  return violations;
}

// Fix violations
function fixViolations(violations) {
  let fixed = 0;

  // Delete temp files
  for (const item of violations.delete) {
    if (DRY_RUN) {
      log(`  [DRY-RUN] Would delete: ${item.name}`, 'yellow');
    } else {
      try {
        fs.unlinkSync(item.path);
        log(`  âœ“ Deleted: ${item.name}`, 'green');
        fixed++;
      } catch (e) {
        log(`  âœ— Failed to delete ${item.name}: ${e.message}`, 'red');
      }
    }
  }

  // Move files
  for (const item of violations.move) {
    const destDir = path.join(ROOT, item.dest);
    const destPath = path.join(destDir, item.name);

    if (DRY_RUN) {
      log(`  [DRY-RUN] Would move: ${item.name} â†’ ${item.dest}`, 'yellow');
    } else {
      try {
        if (!fs.existsSync(destDir)) {
          fs.mkdirSync(destDir, { recursive: true });
        }
        fs.renameSync(item.path, destPath);
        log(`  âœ“ Moved: ${item.name} â†’ ${item.dest}`, 'green');
        fixed++;
      } catch (e) {
        log(`  âœ— Failed to move ${item.name}: ${e.message}`, 'red');
      }
    }
  }

  return fixed;
}

// Main
function main() {
  log('\nğŸ“ Root Folder Cleanup Check', 'cyan');
  log(`   Project: ${path.basename(ROOT)}`, 'cyan');
  log(`   Config: ${CONFIG.name}\n`, 'cyan');

  const violations = scanRoot();
  const total = violations.delete.length + violations.move.length + violations.review.length;

  if (total === 0) {
    log('âœ… Root folder is clean!\n', 'green');
    process.exit(0);
  }

  // Report violations
  if (violations.delete.length > 0) {
    log(`\nğŸ—‘ï¸  Te verwijderen (${violations.delete.length}):`, 'red');
    violations.delete.forEach(f => log(`   - ${f.name}`, 'red'));
  }

  if (violations.move.length > 0) {
    log(`\nğŸ“¦ Te verplaatsen (${violations.move.length}):`, 'yellow');
    violations.move.forEach(f => log(`   - ${f.name} â†’ ${f.dest}`, 'yellow'));
  }

  if (violations.review.length > 0) {
    log(`\nğŸ” Handmatig reviewen (${violations.review.length}):`, 'blue');
    violations.review.forEach(f => log(`   - ${f.name} ${f.isDir ? '(folder)' : ''}`, 'blue'));
  }

  // Fix mode
  if (FIX_MODE) {
    log(`\nğŸ”§ Fixing violations...${DRY_RUN ? ' (DRY RUN)' : ''}\n`, 'cyan');
    const fixed = fixViolations(violations);

    if (!DRY_RUN) {
      log(`\nâœ… Fixed ${fixed} items`, 'green');
      if (violations.review.length > 0) {
        log(`âš ï¸  ${violations.review.length} items need manual review\n`, 'yellow');
      }
    }
  } else {
    log(`\nğŸ’¡ Run with --fix to auto-fix, or --dry-run --fix to preview\n`, 'cyan');
  }

  process.exit(violations.review.length > 0 ? 1 : 0);
}

main();
